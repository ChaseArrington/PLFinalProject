Created by PLY version 3.8 (http://www.dabeaz.com/ply)

Unused terminals:

    QUOTE
    CLASS
    SIMB
    id
    funcDef

Grammar

Rule 0     S' -> exp
Rule 1     exp -> atom
Rule 2     exp -> call
Rule 3     items -> item items
Rule 4     items -> empty
Rule 5     empty -> <empty>
Rule 6     item -> atom
Rule 7     item -> call
Rule 8     item -> empty
Rule 9     call -> item MATH item
Rule 10    call -> item Eq item
Rule 11    call -> LBrack items RBrack
Rule 12    call -> FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY
Rule 13    call -> FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY
Rule 14    call -> FUNC item LPAREN items RPAREN LCURLY items RCURLY
Rule 15    call -> item LPAREN items RPAREN
Rule 16    call -> PRINT items
Rule 17    atom -> bool
Rule 18    atom -> NUM
Rule 19    atom -> MATH
Rule 20    atom -> TEXT
Rule 21    atom -> STRING
Rule 22    atom -> <empty>
Rule 23    bool -> TRUE
Rule 24    bool -> FALSE
Rule 25    atom -> NIL

Terminals, with rules where they appear

CLASS                : 
Eq                   : 10
FALSE                : 24
FUNC                 : 12 13 14
LBrack               : 11
LCURLY               : 12 13 14
LPAREN               : 12 13 14 15
MATH                 : 9 12 13 13 19
NIL                  : 25
NUM                  : 18
PRINT                : 16
QUOTE                : 
RBrack               : 11
RCURLY               : 12 13 14
RPAREN               : 12 13 14 15
SIMB                 : 
STRING               : 21
TEXT                 : 20
TRUE                 : 23
error                : 
funcDef              : 
id                   : 

Nonterminals, with rules where they appear

atom                 : 1 6
bool                 : 17
call                 : 2 7
empty                : 4 8
exp                  : 0
item                 : 3 9 9 10 10 12 12 12 13 13 13 13 14 15
items                : 3 11 12 13 14 14 15 16

Parsing method: LALR

state 0

    (0) S' -> . exp
    (1) exp -> . atom
    (2) exp -> . call
    (17) atom -> . bool
    (18) atom -> . NUM
    (19) atom -> . MATH
    (20) atom -> . TEXT
    (21) atom -> . STRING
    (22) atom -> .
    (25) atom -> . NIL
    (9) call -> . item MATH item
    (10) call -> . item Eq item
    (11) call -> . LBrack items RBrack
    (12) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY
    (13) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY
    (14) call -> . FUNC item LPAREN items RPAREN LCURLY items RCURLY
    (15) call -> . item LPAREN items RPAREN
    (16) call -> . PRINT items
    (23) bool -> . TRUE
    (24) bool -> . FALSE
    (6) item -> . atom
    (7) item -> . call
    (8) item -> . empty
    (5) empty -> .

  ! shift/reduce conflict for MATH resolved as shift
  ! shift/reduce conflict for MATH resolved as shift
  ! reduce/reduce conflict for Eq resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for LPAREN resolved using rule 5 (empty -> .)
    NUM             shift and go to state 5
    MATH            shift and go to state 9
    TEXT            shift and go to state 7
    STRING          shift and go to state 13
    $end            reduce using rule 22 (atom -> .)
    NIL             shift and go to state 12
    LBrack          shift and go to state 8
    FUNC            shift and go to state 4
    PRINT           shift and go to state 1
    TRUE            shift and go to state 6
    FALSE           shift and go to state 14
    Eq              reduce using rule 5 (empty -> .)
    LPAREN          reduce using rule 5 (empty -> .)

  ! MATH            [ reduce using rule 22 (atom -> .) ]
  ! Eq              [ reduce using rule 22 (atom -> .) ]
  ! LPAREN          [ reduce using rule 22 (atom -> .) ]
  ! MATH            [ reduce using rule 5 (empty -> .) ]

    item                           shift and go to state 2
    bool                           shift and go to state 3
    empty                          shift and go to state 10
    call                           shift and go to state 11
    exp                            shift and go to state 15
    atom                           shift and go to state 16

state 1

    (16) call -> PRINT . items
    (3) items -> . item items
    (4) items -> . empty
    (6) item -> . atom
    (7) item -> . call
    (8) item -> . empty
    (5) empty -> .
    (17) atom -> . bool
    (18) atom -> . NUM
    (19) atom -> . MATH
    (20) atom -> . TEXT
    (21) atom -> . STRING
    (22) atom -> .
    (25) atom -> . NIL
    (9) call -> . item MATH item
    (10) call -> . item Eq item
    (11) call -> . LBrack items RBrack
    (12) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY
    (13) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY
    (14) call -> . FUNC item LPAREN items RPAREN LCURLY items RCURLY
    (15) call -> . item LPAREN items RPAREN
    (16) call -> . PRINT items
    (23) bool -> . TRUE
    (24) bool -> . FALSE

  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for MATH resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for MATH resolved as shift
  ! reduce/reduce conflict for Eq resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for LPAREN resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! reduce/reduce conflict for NIL resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for LBrack resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for FUNC resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for PRINT resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for TRUE resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for RBrack resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for RPAREN resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for RCURLY resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for LBrack resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    $end            reduce using rule 5 (empty -> .)
    Eq              reduce using rule 5 (empty -> .)
    LPAREN          reduce using rule 5 (empty -> .)
    RBrack          reduce using rule 5 (empty -> .)
    RPAREN          reduce using rule 5 (empty -> .)
    RCURLY          reduce using rule 5 (empty -> .)
    NUM             shift and go to state 5
    MATH            shift and go to state 9
    TEXT            shift and go to state 7
    STRING          shift and go to state 13
    NIL             shift and go to state 12
    LBrack          shift and go to state 8
    FUNC            shift and go to state 4
    PRINT           shift and go to state 1
    TRUE            shift and go to state 6
    FALSE           shift and go to state 14

  ! MATH            [ reduce using rule 5 (empty -> .) ]
  ! NUM             [ reduce using rule 5 (empty -> .) ]
  ! TEXT            [ reduce using rule 5 (empty -> .) ]
  ! STRING          [ reduce using rule 5 (empty -> .) ]
  ! NIL             [ reduce using rule 5 (empty -> .) ]
  ! LBrack          [ reduce using rule 5 (empty -> .) ]
  ! FUNC            [ reduce using rule 5 (empty -> .) ]
  ! PRINT           [ reduce using rule 5 (empty -> .) ]
  ! TRUE            [ reduce using rule 5 (empty -> .) ]
  ! FALSE           [ reduce using rule 5 (empty -> .) ]
  ! $end            [ reduce using rule 22 (atom -> .) ]
  ! MATH            [ reduce using rule 22 (atom -> .) ]
  ! Eq              [ reduce using rule 22 (atom -> .) ]
  ! LPAREN          [ reduce using rule 22 (atom -> .) ]
  ! NUM             [ reduce using rule 22 (atom -> .) ]
  ! TEXT            [ reduce using rule 22 (atom -> .) ]
  ! STRING          [ reduce using rule 22 (atom -> .) ]
  ! NIL             [ reduce using rule 22 (atom -> .) ]
  ! LBrack          [ reduce using rule 22 (atom -> .) ]
  ! FUNC            [ reduce using rule 22 (atom -> .) ]
  ! PRINT           [ reduce using rule 22 (atom -> .) ]
  ! TRUE            [ reduce using rule 22 (atom -> .) ]
  ! FALSE           [ reduce using rule 22 (atom -> .) ]
  ! RBrack          [ reduce using rule 22 (atom -> .) ]
  ! RPAREN          [ reduce using rule 22 (atom -> .) ]
  ! RCURLY          [ reduce using rule 22 (atom -> .) ]

    item                           shift and go to state 17
    bool                           shift and go to state 3
    empty                          shift and go to state 18
    call                           shift and go to state 19
    atom                           shift and go to state 20
    items                          shift and go to state 21

state 2

    (9) call -> item . MATH item
    (10) call -> item . Eq item
    (15) call -> item . LPAREN items RPAREN

    MATH            shift and go to state 23
    Eq              shift and go to state 24
    LPAREN          shift and go to state 22


state 3

    (17) atom -> bool .

    MATH            reduce using rule 17 (atom -> bool .)
    Eq              reduce using rule 17 (atom -> bool .)
    LPAREN          reduce using rule 17 (atom -> bool .)
    NUM             reduce using rule 17 (atom -> bool .)
    TEXT            reduce using rule 17 (atom -> bool .)
    STRING          reduce using rule 17 (atom -> bool .)
    NIL             reduce using rule 17 (atom -> bool .)
    LBrack          reduce using rule 17 (atom -> bool .)
    FUNC            reduce using rule 17 (atom -> bool .)
    PRINT           reduce using rule 17 (atom -> bool .)
    TRUE            reduce using rule 17 (atom -> bool .)
    FALSE           reduce using rule 17 (atom -> bool .)
    RCURLY          reduce using rule 17 (atom -> bool .)
    $end            reduce using rule 17 (atom -> bool .)
    RBrack          reduce using rule 17 (atom -> bool .)
    RPAREN          reduce using rule 17 (atom -> bool .)


state 4

    (12) call -> FUNC . item LPAREN items RPAREN LCURLY item MATH item RCURLY
    (13) call -> FUNC . item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY
    (14) call -> FUNC . item LPAREN items RPAREN LCURLY items RCURLY
    (6) item -> . atom
    (7) item -> . call
    (8) item -> . empty
    (17) atom -> . bool
    (18) atom -> . NUM
    (19) atom -> . MATH
    (20) atom -> . TEXT
    (21) atom -> . STRING
    (22) atom -> .
    (25) atom -> . NIL
    (9) call -> . item MATH item
    (10) call -> . item Eq item
    (11) call -> . LBrack items RBrack
    (12) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY
    (13) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY
    (14) call -> . FUNC item LPAREN items RPAREN LCURLY items RCURLY
    (15) call -> . item LPAREN items RPAREN
    (16) call -> . PRINT items
    (5) empty -> .
    (23) bool -> . TRUE
    (24) bool -> . FALSE

  ! shift/reduce conflict for MATH resolved as shift
  ! reduce/reduce conflict for LPAREN resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for MATH resolved as shift
  ! reduce/reduce conflict for Eq resolved using rule 5 (empty -> .)
    NUM             shift and go to state 5
    MATH            shift and go to state 9
    TEXT            shift and go to state 7
    STRING          shift and go to state 13
    NIL             shift and go to state 12
    LBrack          shift and go to state 8
    FUNC            shift and go to state 4
    PRINT           shift and go to state 1
    LPAREN          reduce using rule 5 (empty -> .)
    Eq              reduce using rule 5 (empty -> .)
    TRUE            shift and go to state 6
    FALSE           shift and go to state 14

  ! LPAREN          [ reduce using rule 22 (atom -> .) ]
  ! MATH            [ reduce using rule 22 (atom -> .) ]
  ! Eq              [ reduce using rule 22 (atom -> .) ]
  ! MATH            [ reduce using rule 5 (empty -> .) ]

    item                           shift and go to state 25
    bool                           shift and go to state 3
    empty                          shift and go to state 10
    call                           shift and go to state 19
    atom                           shift and go to state 20

state 5

    (18) atom -> NUM .

    MATH            reduce using rule 18 (atom -> NUM .)
    Eq              reduce using rule 18 (atom -> NUM .)
    LPAREN          reduce using rule 18 (atom -> NUM .)
    NUM             reduce using rule 18 (atom -> NUM .)
    TEXT            reduce using rule 18 (atom -> NUM .)
    STRING          reduce using rule 18 (atom -> NUM .)
    NIL             reduce using rule 18 (atom -> NUM .)
    LBrack          reduce using rule 18 (atom -> NUM .)
    FUNC            reduce using rule 18 (atom -> NUM .)
    PRINT           reduce using rule 18 (atom -> NUM .)
    TRUE            reduce using rule 18 (atom -> NUM .)
    FALSE           reduce using rule 18 (atom -> NUM .)
    RCURLY          reduce using rule 18 (atom -> NUM .)
    $end            reduce using rule 18 (atom -> NUM .)
    RBrack          reduce using rule 18 (atom -> NUM .)
    RPAREN          reduce using rule 18 (atom -> NUM .)


state 6

    (23) bool -> TRUE .

    $end            reduce using rule 23 (bool -> TRUE .)
    MATH            reduce using rule 23 (bool -> TRUE .)
    Eq              reduce using rule 23 (bool -> TRUE .)
    LPAREN          reduce using rule 23 (bool -> TRUE .)
    NUM             reduce using rule 23 (bool -> TRUE .)
    TEXT            reduce using rule 23 (bool -> TRUE .)
    STRING          reduce using rule 23 (bool -> TRUE .)
    NIL             reduce using rule 23 (bool -> TRUE .)
    LBrack          reduce using rule 23 (bool -> TRUE .)
    FUNC            reduce using rule 23 (bool -> TRUE .)
    PRINT           reduce using rule 23 (bool -> TRUE .)
    TRUE            reduce using rule 23 (bool -> TRUE .)
    FALSE           reduce using rule 23 (bool -> TRUE .)
    RBrack          reduce using rule 23 (bool -> TRUE .)
    RPAREN          reduce using rule 23 (bool -> TRUE .)
    RCURLY          reduce using rule 23 (bool -> TRUE .)


state 7

    (20) atom -> TEXT .

    MATH            reduce using rule 20 (atom -> TEXT .)
    Eq              reduce using rule 20 (atom -> TEXT .)
    LPAREN          reduce using rule 20 (atom -> TEXT .)
    NUM             reduce using rule 20 (atom -> TEXT .)
    TEXT            reduce using rule 20 (atom -> TEXT .)
    STRING          reduce using rule 20 (atom -> TEXT .)
    NIL             reduce using rule 20 (atom -> TEXT .)
    LBrack          reduce using rule 20 (atom -> TEXT .)
    FUNC            reduce using rule 20 (atom -> TEXT .)
    PRINT           reduce using rule 20 (atom -> TEXT .)
    TRUE            reduce using rule 20 (atom -> TEXT .)
    FALSE           reduce using rule 20 (atom -> TEXT .)
    RCURLY          reduce using rule 20 (atom -> TEXT .)
    $end            reduce using rule 20 (atom -> TEXT .)
    RBrack          reduce using rule 20 (atom -> TEXT .)
    RPAREN          reduce using rule 20 (atom -> TEXT .)


state 8

    (11) call -> LBrack . items RBrack
    (3) items -> . item items
    (4) items -> . empty
    (6) item -> . atom
    (7) item -> . call
    (8) item -> . empty
    (5) empty -> .
    (17) atom -> . bool
    (18) atom -> . NUM
    (19) atom -> . MATH
    (20) atom -> . TEXT
    (21) atom -> . STRING
    (22) atom -> .
    (25) atom -> . NIL
    (9) call -> . item MATH item
    (10) call -> . item Eq item
    (11) call -> . LBrack items RBrack
    (12) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY
    (13) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY
    (14) call -> . FUNC item LPAREN items RPAREN LCURLY items RCURLY
    (15) call -> . item LPAREN items RPAREN
    (16) call -> . PRINT items
    (23) bool -> . TRUE
    (24) bool -> . FALSE

  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for MATH resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for MATH resolved as shift
  ! reduce/reduce conflict for Eq resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for LPAREN resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! reduce/reduce conflict for NIL resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for LBrack resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for FUNC resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for PRINT resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for TRUE resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for RBrack resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for LBrack resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    RBrack          reduce using rule 5 (empty -> .)
    Eq              reduce using rule 5 (empty -> .)
    LPAREN          reduce using rule 5 (empty -> .)
    NUM             shift and go to state 5
    MATH            shift and go to state 9
    TEXT            shift and go to state 7
    STRING          shift and go to state 13
    NIL             shift and go to state 12
    LBrack          shift and go to state 8
    FUNC            shift and go to state 4
    PRINT           shift and go to state 1
    TRUE            shift and go to state 6
    FALSE           shift and go to state 14

  ! MATH            [ reduce using rule 5 (empty -> .) ]
  ! NUM             [ reduce using rule 5 (empty -> .) ]
  ! TEXT            [ reduce using rule 5 (empty -> .) ]
  ! STRING          [ reduce using rule 5 (empty -> .) ]
  ! NIL             [ reduce using rule 5 (empty -> .) ]
  ! LBrack          [ reduce using rule 5 (empty -> .) ]
  ! FUNC            [ reduce using rule 5 (empty -> .) ]
  ! PRINT           [ reduce using rule 5 (empty -> .) ]
  ! TRUE            [ reduce using rule 5 (empty -> .) ]
  ! FALSE           [ reduce using rule 5 (empty -> .) ]
  ! MATH            [ reduce using rule 22 (atom -> .) ]
  ! Eq              [ reduce using rule 22 (atom -> .) ]
  ! LPAREN          [ reduce using rule 22 (atom -> .) ]
  ! NUM             [ reduce using rule 22 (atom -> .) ]
  ! TEXT            [ reduce using rule 22 (atom -> .) ]
  ! STRING          [ reduce using rule 22 (atom -> .) ]
  ! NIL             [ reduce using rule 22 (atom -> .) ]
  ! LBrack          [ reduce using rule 22 (atom -> .) ]
  ! FUNC            [ reduce using rule 22 (atom -> .) ]
  ! PRINT           [ reduce using rule 22 (atom -> .) ]
  ! TRUE            [ reduce using rule 22 (atom -> .) ]
  ! FALSE           [ reduce using rule 22 (atom -> .) ]
  ! RBrack          [ reduce using rule 22 (atom -> .) ]

    item                           shift and go to state 17
    bool                           shift and go to state 3
    empty                          shift and go to state 18
    call                           shift and go to state 19
    atom                           shift and go to state 20
    items                          shift and go to state 26

state 9

    (19) atom -> MATH .

    $end            reduce using rule 19 (atom -> MATH .)
    MATH            reduce using rule 19 (atom -> MATH .)
    Eq              reduce using rule 19 (atom -> MATH .)
    LPAREN          reduce using rule 19 (atom -> MATH .)
    RCURLY          reduce using rule 19 (atom -> MATH .)
    NUM             reduce using rule 19 (atom -> MATH .)
    TEXT            reduce using rule 19 (atom -> MATH .)
    STRING          reduce using rule 19 (atom -> MATH .)
    NIL             reduce using rule 19 (atom -> MATH .)
    LBrack          reduce using rule 19 (atom -> MATH .)
    FUNC            reduce using rule 19 (atom -> MATH .)
    PRINT           reduce using rule 19 (atom -> MATH .)
    TRUE            reduce using rule 19 (atom -> MATH .)
    FALSE           reduce using rule 19 (atom -> MATH .)
    RPAREN          reduce using rule 19 (atom -> MATH .)
    RBrack          reduce using rule 19 (atom -> MATH .)


state 10

    (8) item -> empty .

    $end            reduce using rule 8 (item -> empty .)
    MATH            reduce using rule 8 (item -> empty .)
    Eq              reduce using rule 8 (item -> empty .)
    LPAREN          reduce using rule 8 (item -> empty .)
    NUM             reduce using rule 8 (item -> empty .)
    TEXT            reduce using rule 8 (item -> empty .)
    STRING          reduce using rule 8 (item -> empty .)
    NIL             reduce using rule 8 (item -> empty .)
    LBrack          reduce using rule 8 (item -> empty .)
    FUNC            reduce using rule 8 (item -> empty .)
    PRINT           reduce using rule 8 (item -> empty .)
    TRUE            reduce using rule 8 (item -> empty .)
    FALSE           reduce using rule 8 (item -> empty .)
    RBrack          reduce using rule 8 (item -> empty .)
    RPAREN          reduce using rule 8 (item -> empty .)
    RCURLY          reduce using rule 8 (item -> empty .)


state 11

    (2) exp -> call .
    (7) item -> call .

    $end            reduce using rule 2 (exp -> call .)
    MATH            reduce using rule 7 (item -> call .)
    Eq              reduce using rule 7 (item -> call .)
    LPAREN          reduce using rule 7 (item -> call .)


state 12

    (25) atom -> NIL .

    MATH            reduce using rule 25 (atom -> NIL .)
    Eq              reduce using rule 25 (atom -> NIL .)
    LPAREN          reduce using rule 25 (atom -> NIL .)
    NUM             reduce using rule 25 (atom -> NIL .)
    TEXT            reduce using rule 25 (atom -> NIL .)
    STRING          reduce using rule 25 (atom -> NIL .)
    NIL             reduce using rule 25 (atom -> NIL .)
    LBrack          reduce using rule 25 (atom -> NIL .)
    FUNC            reduce using rule 25 (atom -> NIL .)
    PRINT           reduce using rule 25 (atom -> NIL .)
    TRUE            reduce using rule 25 (atom -> NIL .)
    FALSE           reduce using rule 25 (atom -> NIL .)
    RCURLY          reduce using rule 25 (atom -> NIL .)
    $end            reduce using rule 25 (atom -> NIL .)
    RBrack          reduce using rule 25 (atom -> NIL .)
    RPAREN          reduce using rule 25 (atom -> NIL .)


state 13

    (21) atom -> STRING .

    MATH            reduce using rule 21 (atom -> STRING .)
    Eq              reduce using rule 21 (atom -> STRING .)
    LPAREN          reduce using rule 21 (atom -> STRING .)
    NUM             reduce using rule 21 (atom -> STRING .)
    TEXT            reduce using rule 21 (atom -> STRING .)
    STRING          reduce using rule 21 (atom -> STRING .)
    NIL             reduce using rule 21 (atom -> STRING .)
    LBrack          reduce using rule 21 (atom -> STRING .)
    FUNC            reduce using rule 21 (atom -> STRING .)
    PRINT           reduce using rule 21 (atom -> STRING .)
    TRUE            reduce using rule 21 (atom -> STRING .)
    FALSE           reduce using rule 21 (atom -> STRING .)
    RCURLY          reduce using rule 21 (atom -> STRING .)
    $end            reduce using rule 21 (atom -> STRING .)
    RBrack          reduce using rule 21 (atom -> STRING .)
    RPAREN          reduce using rule 21 (atom -> STRING .)


state 14

    (24) bool -> FALSE .

    $end            reduce using rule 24 (bool -> FALSE .)
    MATH            reduce using rule 24 (bool -> FALSE .)
    Eq              reduce using rule 24 (bool -> FALSE .)
    LPAREN          reduce using rule 24 (bool -> FALSE .)
    NUM             reduce using rule 24 (bool -> FALSE .)
    TEXT            reduce using rule 24 (bool -> FALSE .)
    STRING          reduce using rule 24 (bool -> FALSE .)
    NIL             reduce using rule 24 (bool -> FALSE .)
    LBrack          reduce using rule 24 (bool -> FALSE .)
    FUNC            reduce using rule 24 (bool -> FALSE .)
    PRINT           reduce using rule 24 (bool -> FALSE .)
    TRUE            reduce using rule 24 (bool -> FALSE .)
    FALSE           reduce using rule 24 (bool -> FALSE .)
    RBrack          reduce using rule 24 (bool -> FALSE .)
    RPAREN          reduce using rule 24 (bool -> FALSE .)
    RCURLY          reduce using rule 24 (bool -> FALSE .)


state 15

    (0) S' -> exp .



state 16

    (1) exp -> atom .
    (6) item -> atom .

    $end            reduce using rule 1 (exp -> atom .)
    MATH            reduce using rule 6 (item -> atom .)
    Eq              reduce using rule 6 (item -> atom .)
    LPAREN          reduce using rule 6 (item -> atom .)


state 17

    (3) items -> item . items
    (9) call -> item . MATH item
    (10) call -> item . Eq item
    (15) call -> item . LPAREN items RPAREN
    (3) items -> . item items
    (4) items -> . empty
    (6) item -> . atom
    (7) item -> . call
    (8) item -> . empty
    (5) empty -> .
    (17) atom -> . bool
    (18) atom -> . NUM
    (19) atom -> . MATH
    (20) atom -> . TEXT
    (21) atom -> . STRING
    (22) atom -> .
    (25) atom -> . NIL
    (9) call -> . item MATH item
    (10) call -> . item Eq item
    (11) call -> . LBrack items RBrack
    (12) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY
    (13) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY
    (14) call -> . FUNC item LPAREN items RPAREN LCURLY items RCURLY
    (15) call -> . item LPAREN items RPAREN
    (16) call -> . PRINT items
    (23) bool -> . TRUE
    (24) bool -> . FALSE

  ! shift/reduce conflict for MATH resolved as shift
  ! shift/reduce conflict for Eq resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for MATH resolved as shift
  ! shift/reduce conflict for Eq resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! reduce/reduce conflict for NIL resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for LBrack resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for FUNC resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for PRINT resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for TRUE resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for RBrack resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for RPAREN resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for RCURLY resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for LBrack resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    MATH            shift and go to state 27
    Eq              shift and go to state 24
    LPAREN          shift and go to state 22
    $end            reduce using rule 5 (empty -> .)
    RBrack          reduce using rule 5 (empty -> .)
    RPAREN          reduce using rule 5 (empty -> .)
    RCURLY          reduce using rule 5 (empty -> .)
    NUM             shift and go to state 5
    TEXT            shift and go to state 7
    STRING          shift and go to state 13
    NIL             shift and go to state 12
    LBrack          shift and go to state 8
    FUNC            shift and go to state 4
    PRINT           shift and go to state 1
    TRUE            shift and go to state 6
    FALSE           shift and go to state 14

  ! MATH            [ reduce using rule 5 (empty -> .) ]
  ! Eq              [ reduce using rule 5 (empty -> .) ]
  ! LPAREN          [ reduce using rule 5 (empty -> .) ]
  ! NUM             [ reduce using rule 5 (empty -> .) ]
  ! TEXT            [ reduce using rule 5 (empty -> .) ]
  ! STRING          [ reduce using rule 5 (empty -> .) ]
  ! NIL             [ reduce using rule 5 (empty -> .) ]
  ! LBrack          [ reduce using rule 5 (empty -> .) ]
  ! FUNC            [ reduce using rule 5 (empty -> .) ]
  ! PRINT           [ reduce using rule 5 (empty -> .) ]
  ! TRUE            [ reduce using rule 5 (empty -> .) ]
  ! FALSE           [ reduce using rule 5 (empty -> .) ]
  ! $end            [ reduce using rule 22 (atom -> .) ]
  ! MATH            [ reduce using rule 22 (atom -> .) ]
  ! Eq              [ reduce using rule 22 (atom -> .) ]
  ! LPAREN          [ reduce using rule 22 (atom -> .) ]
  ! NUM             [ reduce using rule 22 (atom -> .) ]
  ! TEXT            [ reduce using rule 22 (atom -> .) ]
  ! STRING          [ reduce using rule 22 (atom -> .) ]
  ! NIL             [ reduce using rule 22 (atom -> .) ]
  ! LBrack          [ reduce using rule 22 (atom -> .) ]
  ! FUNC            [ reduce using rule 22 (atom -> .) ]
  ! PRINT           [ reduce using rule 22 (atom -> .) ]
  ! TRUE            [ reduce using rule 22 (atom -> .) ]
  ! FALSE           [ reduce using rule 22 (atom -> .) ]
  ! RBrack          [ reduce using rule 22 (atom -> .) ]
  ! RPAREN          [ reduce using rule 22 (atom -> .) ]
  ! RCURLY          [ reduce using rule 22 (atom -> .) ]

    item                           shift and go to state 17
    bool                           shift and go to state 3
    empty                          shift and go to state 18
    call                           shift and go to state 19
    atom                           shift and go to state 20
    items                          shift and go to state 28

state 18

    (4) items -> empty .
    (8) item -> empty .

  ! reduce/reduce conflict for $end resolved using rule 4 (items -> empty .)
  ! reduce/reduce conflict for MATH resolved using rule 4 (items -> empty .)
  ! reduce/reduce conflict for Eq resolved using rule 4 (items -> empty .)
  ! reduce/reduce conflict for LPAREN resolved using rule 4 (items -> empty .)
  ! reduce/reduce conflict for NUM resolved using rule 4 (items -> empty .)
  ! reduce/reduce conflict for TEXT resolved using rule 4 (items -> empty .)
  ! reduce/reduce conflict for STRING resolved using rule 4 (items -> empty .)
  ! reduce/reduce conflict for NIL resolved using rule 4 (items -> empty .)
  ! reduce/reduce conflict for LBrack resolved using rule 4 (items -> empty .)
  ! reduce/reduce conflict for FUNC resolved using rule 4 (items -> empty .)
  ! reduce/reduce conflict for PRINT resolved using rule 4 (items -> empty .)
  ! reduce/reduce conflict for TRUE resolved using rule 4 (items -> empty .)
  ! reduce/reduce conflict for FALSE resolved using rule 4 (items -> empty .)
  ! reduce/reduce conflict for RBrack resolved using rule 4 (items -> empty .)
  ! reduce/reduce conflict for RPAREN resolved using rule 4 (items -> empty .)
  ! reduce/reduce conflict for RCURLY resolved using rule 4 (items -> empty .)
    $end            reduce using rule 4 (items -> empty .)
    MATH            reduce using rule 4 (items -> empty .)
    Eq              reduce using rule 4 (items -> empty .)
    LPAREN          reduce using rule 4 (items -> empty .)
    NUM             reduce using rule 4 (items -> empty .)
    TEXT            reduce using rule 4 (items -> empty .)
    STRING          reduce using rule 4 (items -> empty .)
    NIL             reduce using rule 4 (items -> empty .)
    LBrack          reduce using rule 4 (items -> empty .)
    FUNC            reduce using rule 4 (items -> empty .)
    PRINT           reduce using rule 4 (items -> empty .)
    TRUE            reduce using rule 4 (items -> empty .)
    FALSE           reduce using rule 4 (items -> empty .)
    RBrack          reduce using rule 4 (items -> empty .)
    RPAREN          reduce using rule 4 (items -> empty .)
    RCURLY          reduce using rule 4 (items -> empty .)

  ! $end            [ reduce using rule 8 (item -> empty .) ]
  ! MATH            [ reduce using rule 8 (item -> empty .) ]
  ! Eq              [ reduce using rule 8 (item -> empty .) ]
  ! LPAREN          [ reduce using rule 8 (item -> empty .) ]
  ! NUM             [ reduce using rule 8 (item -> empty .) ]
  ! TEXT            [ reduce using rule 8 (item -> empty .) ]
  ! STRING          [ reduce using rule 8 (item -> empty .) ]
  ! NIL             [ reduce using rule 8 (item -> empty .) ]
  ! LBrack          [ reduce using rule 8 (item -> empty .) ]
  ! FUNC            [ reduce using rule 8 (item -> empty .) ]
  ! PRINT           [ reduce using rule 8 (item -> empty .) ]
  ! TRUE            [ reduce using rule 8 (item -> empty .) ]
  ! FALSE           [ reduce using rule 8 (item -> empty .) ]
  ! RBrack          [ reduce using rule 8 (item -> empty .) ]
  ! RPAREN          [ reduce using rule 8 (item -> empty .) ]
  ! RCURLY          [ reduce using rule 8 (item -> empty .) ]


state 19

    (7) item -> call .

    $end            reduce using rule 7 (item -> call .)
    MATH            reduce using rule 7 (item -> call .)
    Eq              reduce using rule 7 (item -> call .)
    LPAREN          reduce using rule 7 (item -> call .)
    NUM             reduce using rule 7 (item -> call .)
    TEXT            reduce using rule 7 (item -> call .)
    STRING          reduce using rule 7 (item -> call .)
    NIL             reduce using rule 7 (item -> call .)
    LBrack          reduce using rule 7 (item -> call .)
    FUNC            reduce using rule 7 (item -> call .)
    PRINT           reduce using rule 7 (item -> call .)
    TRUE            reduce using rule 7 (item -> call .)
    FALSE           reduce using rule 7 (item -> call .)
    RBrack          reduce using rule 7 (item -> call .)
    RPAREN          reduce using rule 7 (item -> call .)
    RCURLY          reduce using rule 7 (item -> call .)


state 20

    (6) item -> atom .

    $end            reduce using rule 6 (item -> atom .)
    MATH            reduce using rule 6 (item -> atom .)
    Eq              reduce using rule 6 (item -> atom .)
    LPAREN          reduce using rule 6 (item -> atom .)
    NUM             reduce using rule 6 (item -> atom .)
    TEXT            reduce using rule 6 (item -> atom .)
    STRING          reduce using rule 6 (item -> atom .)
    NIL             reduce using rule 6 (item -> atom .)
    LBrack          reduce using rule 6 (item -> atom .)
    FUNC            reduce using rule 6 (item -> atom .)
    PRINT           reduce using rule 6 (item -> atom .)
    TRUE            reduce using rule 6 (item -> atom .)
    FALSE           reduce using rule 6 (item -> atom .)
    RBrack          reduce using rule 6 (item -> atom .)
    RPAREN          reduce using rule 6 (item -> atom .)
    RCURLY          reduce using rule 6 (item -> atom .)


state 21

    (16) call -> PRINT items .

    $end            reduce using rule 16 (call -> PRINT items .)
    MATH            reduce using rule 16 (call -> PRINT items .)
    Eq              reduce using rule 16 (call -> PRINT items .)
    LPAREN          reduce using rule 16 (call -> PRINT items .)
    NUM             reduce using rule 16 (call -> PRINT items .)
    TEXT            reduce using rule 16 (call -> PRINT items .)
    STRING          reduce using rule 16 (call -> PRINT items .)
    NIL             reduce using rule 16 (call -> PRINT items .)
    LBrack          reduce using rule 16 (call -> PRINT items .)
    FUNC            reduce using rule 16 (call -> PRINT items .)
    PRINT           reduce using rule 16 (call -> PRINT items .)
    TRUE            reduce using rule 16 (call -> PRINT items .)
    FALSE           reduce using rule 16 (call -> PRINT items .)
    RBrack          reduce using rule 16 (call -> PRINT items .)
    RPAREN          reduce using rule 16 (call -> PRINT items .)
    RCURLY          reduce using rule 16 (call -> PRINT items .)


state 22

    (15) call -> item LPAREN . items RPAREN
    (3) items -> . item items
    (4) items -> . empty
    (6) item -> . atom
    (7) item -> . call
    (8) item -> . empty
    (5) empty -> .
    (17) atom -> . bool
    (18) atom -> . NUM
    (19) atom -> . MATH
    (20) atom -> . TEXT
    (21) atom -> . STRING
    (22) atom -> .
    (25) atom -> . NIL
    (9) call -> . item MATH item
    (10) call -> . item Eq item
    (11) call -> . LBrack items RBrack
    (12) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY
    (13) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY
    (14) call -> . FUNC item LPAREN items RPAREN LCURLY items RCURLY
    (15) call -> . item LPAREN items RPAREN
    (16) call -> . PRINT items
    (23) bool -> . TRUE
    (24) bool -> . FALSE

  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for MATH resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for MATH resolved as shift
  ! reduce/reduce conflict for Eq resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for LPAREN resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! reduce/reduce conflict for NIL resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for LBrack resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for FUNC resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for PRINT resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for TRUE resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for RPAREN resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for LBrack resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    RPAREN          reduce using rule 5 (empty -> .)
    Eq              reduce using rule 5 (empty -> .)
    LPAREN          reduce using rule 5 (empty -> .)
    NUM             shift and go to state 5
    MATH            shift and go to state 9
    TEXT            shift and go to state 7
    STRING          shift and go to state 13
    NIL             shift and go to state 12
    LBrack          shift and go to state 8
    FUNC            shift and go to state 4
    PRINT           shift and go to state 1
    TRUE            shift and go to state 6
    FALSE           shift and go to state 14

  ! MATH            [ reduce using rule 5 (empty -> .) ]
  ! NUM             [ reduce using rule 5 (empty -> .) ]
  ! TEXT            [ reduce using rule 5 (empty -> .) ]
  ! STRING          [ reduce using rule 5 (empty -> .) ]
  ! NIL             [ reduce using rule 5 (empty -> .) ]
  ! LBrack          [ reduce using rule 5 (empty -> .) ]
  ! FUNC            [ reduce using rule 5 (empty -> .) ]
  ! PRINT           [ reduce using rule 5 (empty -> .) ]
  ! TRUE            [ reduce using rule 5 (empty -> .) ]
  ! FALSE           [ reduce using rule 5 (empty -> .) ]
  ! MATH            [ reduce using rule 22 (atom -> .) ]
  ! Eq              [ reduce using rule 22 (atom -> .) ]
  ! LPAREN          [ reduce using rule 22 (atom -> .) ]
  ! NUM             [ reduce using rule 22 (atom -> .) ]
  ! TEXT            [ reduce using rule 22 (atom -> .) ]
  ! STRING          [ reduce using rule 22 (atom -> .) ]
  ! NIL             [ reduce using rule 22 (atom -> .) ]
  ! LBrack          [ reduce using rule 22 (atom -> .) ]
  ! FUNC            [ reduce using rule 22 (atom -> .) ]
  ! PRINT           [ reduce using rule 22 (atom -> .) ]
  ! TRUE            [ reduce using rule 22 (atom -> .) ]
  ! FALSE           [ reduce using rule 22 (atom -> .) ]
  ! RPAREN          [ reduce using rule 22 (atom -> .) ]

    item                           shift and go to state 17
    bool                           shift and go to state 3
    empty                          shift and go to state 18
    call                           shift and go to state 19
    atom                           shift and go to state 20
    items                          shift and go to state 29

state 23

    (9) call -> item MATH . item
    (6) item -> . atom
    (7) item -> . call
    (8) item -> . empty
    (17) atom -> . bool
    (18) atom -> . NUM
    (19) atom -> . MATH
    (20) atom -> . TEXT
    (21) atom -> . STRING
    (22) atom -> .
    (25) atom -> . NIL
    (9) call -> . item MATH item
    (10) call -> . item Eq item
    (11) call -> . LBrack items RBrack
    (12) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY
    (13) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY
    (14) call -> . FUNC item LPAREN items RPAREN LCURLY items RCURLY
    (15) call -> . item LPAREN items RPAREN
    (16) call -> . PRINT items
    (5) empty -> .
    (23) bool -> . TRUE
    (24) bool -> . FALSE

  ! shift/reduce conflict for MATH resolved as shift
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for LBrack resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for MATH resolved as shift
  ! reduce/reduce conflict for Eq resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for LPAREN resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for LBrack resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! reduce/reduce conflict for TRUE resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for RBrack resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for RPAREN resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for RCURLY resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    NUM             shift and go to state 5
    MATH            shift and go to state 9
    TEXT            shift and go to state 7
    STRING          shift and go to state 13
    NIL             shift and go to state 12
    LBrack          shift and go to state 8
    FUNC            shift and go to state 4
    PRINT           shift and go to state 1
    $end            reduce using rule 5 (empty -> .)
    Eq              reduce using rule 5 (empty -> .)
    LPAREN          reduce using rule 5 (empty -> .)
    RBrack          reduce using rule 5 (empty -> .)
    RPAREN          reduce using rule 5 (empty -> .)
    RCURLY          reduce using rule 5 (empty -> .)
    TRUE            shift and go to state 6
    FALSE           shift and go to state 14

  ! $end            [ reduce using rule 22 (atom -> .) ]
  ! MATH            [ reduce using rule 22 (atom -> .) ]
  ! Eq              [ reduce using rule 22 (atom -> .) ]
  ! LPAREN          [ reduce using rule 22 (atom -> .) ]
  ! NUM             [ reduce using rule 22 (atom -> .) ]
  ! TEXT            [ reduce using rule 22 (atom -> .) ]
  ! STRING          [ reduce using rule 22 (atom -> .) ]
  ! NIL             [ reduce using rule 22 (atom -> .) ]
  ! LBrack          [ reduce using rule 22 (atom -> .) ]
  ! FUNC            [ reduce using rule 22 (atom -> .) ]
  ! PRINT           [ reduce using rule 22 (atom -> .) ]
  ! TRUE            [ reduce using rule 22 (atom -> .) ]
  ! FALSE           [ reduce using rule 22 (atom -> .) ]
  ! RBrack          [ reduce using rule 22 (atom -> .) ]
  ! RPAREN          [ reduce using rule 22 (atom -> .) ]
  ! RCURLY          [ reduce using rule 22 (atom -> .) ]
  ! MATH            [ reduce using rule 5 (empty -> .) ]
  ! NUM             [ reduce using rule 5 (empty -> .) ]
  ! TEXT            [ reduce using rule 5 (empty -> .) ]
  ! STRING          [ reduce using rule 5 (empty -> .) ]
  ! NIL             [ reduce using rule 5 (empty -> .) ]
  ! LBrack          [ reduce using rule 5 (empty -> .) ]
  ! FUNC            [ reduce using rule 5 (empty -> .) ]
  ! PRINT           [ reduce using rule 5 (empty -> .) ]
  ! TRUE            [ reduce using rule 5 (empty -> .) ]
  ! FALSE           [ reduce using rule 5 (empty -> .) ]

    item                           shift and go to state 30
    bool                           shift and go to state 3
    empty                          shift and go to state 10
    call                           shift and go to state 19
    atom                           shift and go to state 20

state 24

    (10) call -> item Eq . item
    (6) item -> . atom
    (7) item -> . call
    (8) item -> . empty
    (17) atom -> . bool
    (18) atom -> . NUM
    (19) atom -> . MATH
    (20) atom -> . TEXT
    (21) atom -> . STRING
    (22) atom -> .
    (25) atom -> . NIL
    (9) call -> . item MATH item
    (10) call -> . item Eq item
    (11) call -> . LBrack items RBrack
    (12) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY
    (13) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY
    (14) call -> . FUNC item LPAREN items RPAREN LCURLY items RCURLY
    (15) call -> . item LPAREN items RPAREN
    (16) call -> . PRINT items
    (5) empty -> .
    (23) bool -> . TRUE
    (24) bool -> . FALSE

  ! shift/reduce conflict for MATH resolved as shift
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for LBrack resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for MATH resolved as shift
  ! reduce/reduce conflict for Eq resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for LPAREN resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for LBrack resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! reduce/reduce conflict for TRUE resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for RBrack resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for RPAREN resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for RCURLY resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    NUM             shift and go to state 5
    MATH            shift and go to state 9
    TEXT            shift and go to state 7
    STRING          shift and go to state 13
    NIL             shift and go to state 12
    LBrack          shift and go to state 8
    FUNC            shift and go to state 4
    PRINT           shift and go to state 1
    $end            reduce using rule 5 (empty -> .)
    Eq              reduce using rule 5 (empty -> .)
    LPAREN          reduce using rule 5 (empty -> .)
    RBrack          reduce using rule 5 (empty -> .)
    RPAREN          reduce using rule 5 (empty -> .)
    RCURLY          reduce using rule 5 (empty -> .)
    TRUE            shift and go to state 6
    FALSE           shift and go to state 14

  ! $end            [ reduce using rule 22 (atom -> .) ]
  ! MATH            [ reduce using rule 22 (atom -> .) ]
  ! Eq              [ reduce using rule 22 (atom -> .) ]
  ! LPAREN          [ reduce using rule 22 (atom -> .) ]
  ! NUM             [ reduce using rule 22 (atom -> .) ]
  ! TEXT            [ reduce using rule 22 (atom -> .) ]
  ! STRING          [ reduce using rule 22 (atom -> .) ]
  ! NIL             [ reduce using rule 22 (atom -> .) ]
  ! LBrack          [ reduce using rule 22 (atom -> .) ]
  ! FUNC            [ reduce using rule 22 (atom -> .) ]
  ! PRINT           [ reduce using rule 22 (atom -> .) ]
  ! TRUE            [ reduce using rule 22 (atom -> .) ]
  ! FALSE           [ reduce using rule 22 (atom -> .) ]
  ! RBrack          [ reduce using rule 22 (atom -> .) ]
  ! RPAREN          [ reduce using rule 22 (atom -> .) ]
  ! RCURLY          [ reduce using rule 22 (atom -> .) ]
  ! MATH            [ reduce using rule 5 (empty -> .) ]
  ! NUM             [ reduce using rule 5 (empty -> .) ]
  ! TEXT            [ reduce using rule 5 (empty -> .) ]
  ! STRING          [ reduce using rule 5 (empty -> .) ]
  ! NIL             [ reduce using rule 5 (empty -> .) ]
  ! LBrack          [ reduce using rule 5 (empty -> .) ]
  ! FUNC            [ reduce using rule 5 (empty -> .) ]
  ! PRINT           [ reduce using rule 5 (empty -> .) ]
  ! TRUE            [ reduce using rule 5 (empty -> .) ]
  ! FALSE           [ reduce using rule 5 (empty -> .) ]

    item                           shift and go to state 31
    bool                           shift and go to state 3
    empty                          shift and go to state 10
    call                           shift and go to state 19
    atom                           shift and go to state 20

state 25

    (12) call -> FUNC item . LPAREN items RPAREN LCURLY item MATH item RCURLY
    (13) call -> FUNC item . LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY
    (14) call -> FUNC item . LPAREN items RPAREN LCURLY items RCURLY
    (9) call -> item . MATH item
    (10) call -> item . Eq item
    (15) call -> item . LPAREN items RPAREN

    LPAREN          shift and go to state 32
    MATH            shift and go to state 23
    Eq              shift and go to state 24


state 26

    (11) call -> LBrack items . RBrack

    RBrack          shift and go to state 33


state 27

    (9) call -> item MATH . item
    (19) atom -> MATH .
    (6) item -> . atom
    (7) item -> . call
    (8) item -> . empty
    (17) atom -> . bool
    (18) atom -> . NUM
    (19) atom -> . MATH
    (20) atom -> . TEXT
    (21) atom -> . STRING
    (22) atom -> .
    (25) atom -> . NIL
    (9) call -> . item MATH item
    (10) call -> . item Eq item
    (11) call -> . LBrack items RBrack
    (12) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY
    (13) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY
    (14) call -> . FUNC item LPAREN items RPAREN LCURLY items RCURLY
    (15) call -> . item LPAREN items RPAREN
    (16) call -> . PRINT items
    (5) empty -> .
    (23) bool -> . TRUE
    (24) bool -> . FALSE

  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for MATH resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 19 (atom -> MATH .)
  ! shift/reduce conflict for MATH resolved as shift
  ! reduce/reduce conflict for Eq resolved using rule 19 (atom -> MATH .)
  ! reduce/reduce conflict for LPAREN resolved using rule 19 (atom -> MATH .)
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! reduce/reduce conflict for NIL resolved using rule 19 (atom -> MATH .)
  ! reduce/reduce conflict for LBrack resolved using rule 19 (atom -> MATH .)
  ! reduce/reduce conflict for FUNC resolved using rule 19 (atom -> MATH .)
  ! reduce/reduce conflict for PRINT resolved using rule 19 (atom -> MATH .)
  ! reduce/reduce conflict for TRUE resolved using rule 19 (atom -> MATH .)
  ! reduce/reduce conflict for FALSE resolved using rule 19 (atom -> MATH .)
  ! reduce/reduce conflict for RBrack resolved using rule 19 (atom -> MATH .)
  ! reduce/reduce conflict for RPAREN resolved using rule 19 (atom -> MATH .)
  ! reduce/reduce conflict for RCURLY resolved using rule 19 (atom -> MATH .)
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for LBrack resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for MATH resolved as shift
  ! reduce/reduce conflict for Eq resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for LPAREN resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for LBrack resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! reduce/reduce conflict for TRUE resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for RBrack resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for RPAREN resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for RCURLY resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    NUM             shift and go to state 5
    MATH            shift and go to state 9
    TEXT            shift and go to state 7
    STRING          shift and go to state 13
    NIL             shift and go to state 12
    LBrack          shift and go to state 8
    FUNC            shift and go to state 4
    PRINT           shift and go to state 1
    $end            reduce using rule 5 (empty -> .)
    Eq              reduce using rule 5 (empty -> .)
    LPAREN          reduce using rule 5 (empty -> .)
    RBrack          reduce using rule 5 (empty -> .)
    RPAREN          reduce using rule 5 (empty -> .)
    RCURLY          reduce using rule 5 (empty -> .)
    TRUE            shift and go to state 6
    FALSE           shift and go to state 14

  ! $end            [ reduce using rule 19 (atom -> MATH .) ]
  ! MATH            [ reduce using rule 19 (atom -> MATH .) ]
  ! Eq              [ reduce using rule 19 (atom -> MATH .) ]
  ! LPAREN          [ reduce using rule 19 (atom -> MATH .) ]
  ! NUM             [ reduce using rule 19 (atom -> MATH .) ]
  ! TEXT            [ reduce using rule 19 (atom -> MATH .) ]
  ! STRING          [ reduce using rule 19 (atom -> MATH .) ]
  ! NIL             [ reduce using rule 19 (atom -> MATH .) ]
  ! LBrack          [ reduce using rule 19 (atom -> MATH .) ]
  ! FUNC            [ reduce using rule 19 (atom -> MATH .) ]
  ! PRINT           [ reduce using rule 19 (atom -> MATH .) ]
  ! TRUE            [ reduce using rule 19 (atom -> MATH .) ]
  ! FALSE           [ reduce using rule 19 (atom -> MATH .) ]
  ! RBrack          [ reduce using rule 19 (atom -> MATH .) ]
  ! RPAREN          [ reduce using rule 19 (atom -> MATH .) ]
  ! RCURLY          [ reduce using rule 19 (atom -> MATH .) ]
  ! $end            [ reduce using rule 22 (atom -> .) ]
  ! MATH            [ reduce using rule 22 (atom -> .) ]
  ! Eq              [ reduce using rule 22 (atom -> .) ]
  ! LPAREN          [ reduce using rule 22 (atom -> .) ]
  ! NUM             [ reduce using rule 22 (atom -> .) ]
  ! TEXT            [ reduce using rule 22 (atom -> .) ]
  ! STRING          [ reduce using rule 22 (atom -> .) ]
  ! NIL             [ reduce using rule 22 (atom -> .) ]
  ! LBrack          [ reduce using rule 22 (atom -> .) ]
  ! FUNC            [ reduce using rule 22 (atom -> .) ]
  ! PRINT           [ reduce using rule 22 (atom -> .) ]
  ! TRUE            [ reduce using rule 22 (atom -> .) ]
  ! FALSE           [ reduce using rule 22 (atom -> .) ]
  ! RBrack          [ reduce using rule 22 (atom -> .) ]
  ! RPAREN          [ reduce using rule 22 (atom -> .) ]
  ! RCURLY          [ reduce using rule 22 (atom -> .) ]
  ! MATH            [ reduce using rule 5 (empty -> .) ]
  ! NUM             [ reduce using rule 5 (empty -> .) ]
  ! TEXT            [ reduce using rule 5 (empty -> .) ]
  ! STRING          [ reduce using rule 5 (empty -> .) ]
  ! NIL             [ reduce using rule 5 (empty -> .) ]
  ! LBrack          [ reduce using rule 5 (empty -> .) ]
  ! FUNC            [ reduce using rule 5 (empty -> .) ]
  ! PRINT           [ reduce using rule 5 (empty -> .) ]
  ! TRUE            [ reduce using rule 5 (empty -> .) ]
  ! FALSE           [ reduce using rule 5 (empty -> .) ]

    item                           shift and go to state 30
    bool                           shift and go to state 3
    empty                          shift and go to state 10
    call                           shift and go to state 19
    atom                           shift and go to state 20

state 28

    (3) items -> item items .

    $end            reduce using rule 3 (items -> item items .)
    MATH            reduce using rule 3 (items -> item items .)
    Eq              reduce using rule 3 (items -> item items .)
    LPAREN          reduce using rule 3 (items -> item items .)
    NUM             reduce using rule 3 (items -> item items .)
    TEXT            reduce using rule 3 (items -> item items .)
    STRING          reduce using rule 3 (items -> item items .)
    NIL             reduce using rule 3 (items -> item items .)
    LBrack          reduce using rule 3 (items -> item items .)
    FUNC            reduce using rule 3 (items -> item items .)
    PRINT           reduce using rule 3 (items -> item items .)
    TRUE            reduce using rule 3 (items -> item items .)
    FALSE           reduce using rule 3 (items -> item items .)
    RBrack          reduce using rule 3 (items -> item items .)
    RPAREN          reduce using rule 3 (items -> item items .)
    RCURLY          reduce using rule 3 (items -> item items .)


state 29

    (15) call -> item LPAREN items . RPAREN

    RPAREN          shift and go to state 34


state 30

    (9) call -> item MATH item .
    (9) call -> item . MATH item
    (10) call -> item . Eq item
    (15) call -> item . LPAREN items RPAREN

  ! shift/reduce conflict for MATH resolved as shift
  ! shift/reduce conflict for Eq resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    $end            reduce using rule 9 (call -> item MATH item .)
    NUM             reduce using rule 9 (call -> item MATH item .)
    TEXT            reduce using rule 9 (call -> item MATH item .)
    STRING          reduce using rule 9 (call -> item MATH item .)
    NIL             reduce using rule 9 (call -> item MATH item .)
    LBrack          reduce using rule 9 (call -> item MATH item .)
    FUNC            reduce using rule 9 (call -> item MATH item .)
    PRINT           reduce using rule 9 (call -> item MATH item .)
    TRUE            reduce using rule 9 (call -> item MATH item .)
    FALSE           reduce using rule 9 (call -> item MATH item .)
    RBrack          reduce using rule 9 (call -> item MATH item .)
    RPAREN          reduce using rule 9 (call -> item MATH item .)
    RCURLY          reduce using rule 9 (call -> item MATH item .)
    MATH            shift and go to state 23
    Eq              shift and go to state 24
    LPAREN          shift and go to state 22

  ! MATH            [ reduce using rule 9 (call -> item MATH item .) ]
  ! Eq              [ reduce using rule 9 (call -> item MATH item .) ]
  ! LPAREN          [ reduce using rule 9 (call -> item MATH item .) ]


state 31

    (10) call -> item Eq item .
    (9) call -> item . MATH item
    (10) call -> item . Eq item
    (15) call -> item . LPAREN items RPAREN

  ! shift/reduce conflict for MATH resolved as shift
  ! shift/reduce conflict for Eq resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    $end            reduce using rule 10 (call -> item Eq item .)
    NUM             reduce using rule 10 (call -> item Eq item .)
    TEXT            reduce using rule 10 (call -> item Eq item .)
    STRING          reduce using rule 10 (call -> item Eq item .)
    NIL             reduce using rule 10 (call -> item Eq item .)
    LBrack          reduce using rule 10 (call -> item Eq item .)
    FUNC            reduce using rule 10 (call -> item Eq item .)
    PRINT           reduce using rule 10 (call -> item Eq item .)
    TRUE            reduce using rule 10 (call -> item Eq item .)
    FALSE           reduce using rule 10 (call -> item Eq item .)
    RBrack          reduce using rule 10 (call -> item Eq item .)
    RPAREN          reduce using rule 10 (call -> item Eq item .)
    RCURLY          reduce using rule 10 (call -> item Eq item .)
    MATH            shift and go to state 23
    Eq              shift and go to state 24
    LPAREN          shift and go to state 22

  ! MATH            [ reduce using rule 10 (call -> item Eq item .) ]
  ! Eq              [ reduce using rule 10 (call -> item Eq item .) ]
  ! LPAREN          [ reduce using rule 10 (call -> item Eq item .) ]


state 32

    (12) call -> FUNC item LPAREN . items RPAREN LCURLY item MATH item RCURLY
    (13) call -> FUNC item LPAREN . items RPAREN LCURLY item MATH item MATH item RCURLY
    (14) call -> FUNC item LPAREN . items RPAREN LCURLY items RCURLY
    (15) call -> item LPAREN . items RPAREN
    (3) items -> . item items
    (4) items -> . empty
    (6) item -> . atom
    (7) item -> . call
    (8) item -> . empty
    (5) empty -> .
    (17) atom -> . bool
    (18) atom -> . NUM
    (19) atom -> . MATH
    (20) atom -> . TEXT
    (21) atom -> . STRING
    (22) atom -> .
    (25) atom -> . NIL
    (9) call -> . item MATH item
    (10) call -> . item Eq item
    (11) call -> . LBrack items RBrack
    (12) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY
    (13) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY
    (14) call -> . FUNC item LPAREN items RPAREN LCURLY items RCURLY
    (15) call -> . item LPAREN items RPAREN
    (16) call -> . PRINT items
    (23) bool -> . TRUE
    (24) bool -> . FALSE

  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for MATH resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for MATH resolved as shift
  ! reduce/reduce conflict for Eq resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for LPAREN resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! reduce/reduce conflict for NIL resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for LBrack resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for FUNC resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for PRINT resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for TRUE resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for RPAREN resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for LBrack resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    RPAREN          reduce using rule 5 (empty -> .)
    Eq              reduce using rule 5 (empty -> .)
    LPAREN          reduce using rule 5 (empty -> .)
    NUM             shift and go to state 5
    MATH            shift and go to state 9
    TEXT            shift and go to state 7
    STRING          shift and go to state 13
    NIL             shift and go to state 12
    LBrack          shift and go to state 8
    FUNC            shift and go to state 4
    PRINT           shift and go to state 1
    TRUE            shift and go to state 6
    FALSE           shift and go to state 14

  ! MATH            [ reduce using rule 5 (empty -> .) ]
  ! NUM             [ reduce using rule 5 (empty -> .) ]
  ! TEXT            [ reduce using rule 5 (empty -> .) ]
  ! STRING          [ reduce using rule 5 (empty -> .) ]
  ! NIL             [ reduce using rule 5 (empty -> .) ]
  ! LBrack          [ reduce using rule 5 (empty -> .) ]
  ! FUNC            [ reduce using rule 5 (empty -> .) ]
  ! PRINT           [ reduce using rule 5 (empty -> .) ]
  ! TRUE            [ reduce using rule 5 (empty -> .) ]
  ! FALSE           [ reduce using rule 5 (empty -> .) ]
  ! MATH            [ reduce using rule 22 (atom -> .) ]
  ! Eq              [ reduce using rule 22 (atom -> .) ]
  ! LPAREN          [ reduce using rule 22 (atom -> .) ]
  ! NUM             [ reduce using rule 22 (atom -> .) ]
  ! TEXT            [ reduce using rule 22 (atom -> .) ]
  ! STRING          [ reduce using rule 22 (atom -> .) ]
  ! NIL             [ reduce using rule 22 (atom -> .) ]
  ! LBrack          [ reduce using rule 22 (atom -> .) ]
  ! FUNC            [ reduce using rule 22 (atom -> .) ]
  ! PRINT           [ reduce using rule 22 (atom -> .) ]
  ! TRUE            [ reduce using rule 22 (atom -> .) ]
  ! FALSE           [ reduce using rule 22 (atom -> .) ]
  ! RPAREN          [ reduce using rule 22 (atom -> .) ]

    item                           shift and go to state 17
    bool                           shift and go to state 3
    empty                          shift and go to state 18
    call                           shift and go to state 19
    atom                           shift and go to state 20
    items                          shift and go to state 35

state 33

    (11) call -> LBrack items RBrack .

    $end            reduce using rule 11 (call -> LBrack items RBrack .)
    MATH            reduce using rule 11 (call -> LBrack items RBrack .)
    Eq              reduce using rule 11 (call -> LBrack items RBrack .)
    LPAREN          reduce using rule 11 (call -> LBrack items RBrack .)
    NUM             reduce using rule 11 (call -> LBrack items RBrack .)
    TEXT            reduce using rule 11 (call -> LBrack items RBrack .)
    STRING          reduce using rule 11 (call -> LBrack items RBrack .)
    NIL             reduce using rule 11 (call -> LBrack items RBrack .)
    LBrack          reduce using rule 11 (call -> LBrack items RBrack .)
    FUNC            reduce using rule 11 (call -> LBrack items RBrack .)
    PRINT           reduce using rule 11 (call -> LBrack items RBrack .)
    TRUE            reduce using rule 11 (call -> LBrack items RBrack .)
    FALSE           reduce using rule 11 (call -> LBrack items RBrack .)
    RBrack          reduce using rule 11 (call -> LBrack items RBrack .)
    RPAREN          reduce using rule 11 (call -> LBrack items RBrack .)
    RCURLY          reduce using rule 11 (call -> LBrack items RBrack .)


state 34

    (15) call -> item LPAREN items RPAREN .

    $end            reduce using rule 15 (call -> item LPAREN items RPAREN .)
    MATH            reduce using rule 15 (call -> item LPAREN items RPAREN .)
    Eq              reduce using rule 15 (call -> item LPAREN items RPAREN .)
    LPAREN          reduce using rule 15 (call -> item LPAREN items RPAREN .)
    NUM             reduce using rule 15 (call -> item LPAREN items RPAREN .)
    TEXT            reduce using rule 15 (call -> item LPAREN items RPAREN .)
    STRING          reduce using rule 15 (call -> item LPAREN items RPAREN .)
    NIL             reduce using rule 15 (call -> item LPAREN items RPAREN .)
    LBrack          reduce using rule 15 (call -> item LPAREN items RPAREN .)
    FUNC            reduce using rule 15 (call -> item LPAREN items RPAREN .)
    PRINT           reduce using rule 15 (call -> item LPAREN items RPAREN .)
    TRUE            reduce using rule 15 (call -> item LPAREN items RPAREN .)
    FALSE           reduce using rule 15 (call -> item LPAREN items RPAREN .)
    RBrack          reduce using rule 15 (call -> item LPAREN items RPAREN .)
    RPAREN          reduce using rule 15 (call -> item LPAREN items RPAREN .)
    RCURLY          reduce using rule 15 (call -> item LPAREN items RPAREN .)


state 35

    (12) call -> FUNC item LPAREN items . RPAREN LCURLY item MATH item RCURLY
    (13) call -> FUNC item LPAREN items . RPAREN LCURLY item MATH item MATH item RCURLY
    (14) call -> FUNC item LPAREN items . RPAREN LCURLY items RCURLY
    (15) call -> item LPAREN items . RPAREN

    RPAREN          shift and go to state 36


state 36

    (12) call -> FUNC item LPAREN items RPAREN . LCURLY item MATH item RCURLY
    (13) call -> FUNC item LPAREN items RPAREN . LCURLY item MATH item MATH item RCURLY
    (14) call -> FUNC item LPAREN items RPAREN . LCURLY items RCURLY
    (15) call -> item LPAREN items RPAREN .

    LCURLY          shift and go to state 37
    LPAREN          reduce using rule 15 (call -> item LPAREN items RPAREN .)
    MATH            reduce using rule 15 (call -> item LPAREN items RPAREN .)
    Eq              reduce using rule 15 (call -> item LPAREN items RPAREN .)


state 37

    (12) call -> FUNC item LPAREN items RPAREN LCURLY . item MATH item RCURLY
    (13) call -> FUNC item LPAREN items RPAREN LCURLY . item MATH item MATH item RCURLY
    (14) call -> FUNC item LPAREN items RPAREN LCURLY . items RCURLY
    (6) item -> . atom
    (7) item -> . call
    (8) item -> . empty
    (3) items -> . item items
    (4) items -> . empty
    (17) atom -> . bool
    (18) atom -> . NUM
    (19) atom -> . MATH
    (20) atom -> . TEXT
    (21) atom -> . STRING
    (22) atom -> .
    (25) atom -> . NIL
    (9) call -> . item MATH item
    (10) call -> . item Eq item
    (11) call -> . LBrack items RBrack
    (12) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY
    (13) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY
    (14) call -> . FUNC item LPAREN items RPAREN LCURLY items RCURLY
    (15) call -> . item LPAREN items RPAREN
    (16) call -> . PRINT items
    (5) empty -> .
    (23) bool -> . TRUE
    (24) bool -> . FALSE

  ! shift/reduce conflict for MATH resolved as shift
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for LBrack resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for MATH resolved as shift
  ! reduce/reduce conflict for Eq resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for LPAREN resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for LBrack resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! reduce/reduce conflict for TRUE resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for RCURLY resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    NUM             shift and go to state 5
    MATH            shift and go to state 9
    TEXT            shift and go to state 7
    STRING          shift and go to state 13
    NIL             shift and go to state 12
    LBrack          shift and go to state 8
    FUNC            shift and go to state 4
    PRINT           shift and go to state 1
    Eq              reduce using rule 5 (empty -> .)
    LPAREN          reduce using rule 5 (empty -> .)
    RCURLY          reduce using rule 5 (empty -> .)
    TRUE            shift and go to state 6
    FALSE           shift and go to state 14

  ! MATH            [ reduce using rule 22 (atom -> .) ]
  ! Eq              [ reduce using rule 22 (atom -> .) ]
  ! LPAREN          [ reduce using rule 22 (atom -> .) ]
  ! NUM             [ reduce using rule 22 (atom -> .) ]
  ! TEXT            [ reduce using rule 22 (atom -> .) ]
  ! STRING          [ reduce using rule 22 (atom -> .) ]
  ! NIL             [ reduce using rule 22 (atom -> .) ]
  ! LBrack          [ reduce using rule 22 (atom -> .) ]
  ! FUNC            [ reduce using rule 22 (atom -> .) ]
  ! PRINT           [ reduce using rule 22 (atom -> .) ]
  ! TRUE            [ reduce using rule 22 (atom -> .) ]
  ! FALSE           [ reduce using rule 22 (atom -> .) ]
  ! RCURLY          [ reduce using rule 22 (atom -> .) ]
  ! MATH            [ reduce using rule 5 (empty -> .) ]
  ! NUM             [ reduce using rule 5 (empty -> .) ]
  ! TEXT            [ reduce using rule 5 (empty -> .) ]
  ! STRING          [ reduce using rule 5 (empty -> .) ]
  ! NIL             [ reduce using rule 5 (empty -> .) ]
  ! LBrack          [ reduce using rule 5 (empty -> .) ]
  ! FUNC            [ reduce using rule 5 (empty -> .) ]
  ! PRINT           [ reduce using rule 5 (empty -> .) ]
  ! TRUE            [ reduce using rule 5 (empty -> .) ]
  ! FALSE           [ reduce using rule 5 (empty -> .) ]

    item                           shift and go to state 38
    bool                           shift and go to state 3
    empty                          shift and go to state 39
    call                           shift and go to state 19
    atom                           shift and go to state 20
    items                          shift and go to state 40

state 38

    (12) call -> FUNC item LPAREN items RPAREN LCURLY item . MATH item RCURLY
    (13) call -> FUNC item LPAREN items RPAREN LCURLY item . MATH item MATH item RCURLY
    (3) items -> item . items
    (9) call -> item . MATH item
    (10) call -> item . Eq item
    (15) call -> item . LPAREN items RPAREN
    (3) items -> . item items
    (4) items -> . empty
    (6) item -> . atom
    (7) item -> . call
    (8) item -> . empty
    (5) empty -> .
    (17) atom -> . bool
    (18) atom -> . NUM
    (19) atom -> . MATH
    (20) atom -> . TEXT
    (21) atom -> . STRING
    (22) atom -> .
    (25) atom -> . NIL
    (9) call -> . item MATH item
    (10) call -> . item Eq item
    (11) call -> . LBrack items RBrack
    (12) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY
    (13) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY
    (14) call -> . FUNC item LPAREN items RPAREN LCURLY items RCURLY
    (15) call -> . item LPAREN items RPAREN
    (16) call -> . PRINT items
    (23) bool -> . TRUE
    (24) bool -> . FALSE

  ! shift/reduce conflict for MATH resolved as shift
  ! shift/reduce conflict for Eq resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for MATH resolved as shift
  ! shift/reduce conflict for Eq resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! reduce/reduce conflict for NIL resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for LBrack resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for FUNC resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for PRINT resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for TRUE resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for RCURLY resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for LBrack resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    MATH            shift and go to state 41
    Eq              shift and go to state 24
    LPAREN          shift and go to state 22
    RCURLY          reduce using rule 5 (empty -> .)
    NUM             shift and go to state 5
    TEXT            shift and go to state 7
    STRING          shift and go to state 13
    NIL             shift and go to state 12
    LBrack          shift and go to state 8
    FUNC            shift and go to state 4
    PRINT           shift and go to state 1
    TRUE            shift and go to state 6
    FALSE           shift and go to state 14

  ! MATH            [ reduce using rule 5 (empty -> .) ]
  ! Eq              [ reduce using rule 5 (empty -> .) ]
  ! LPAREN          [ reduce using rule 5 (empty -> .) ]
  ! NUM             [ reduce using rule 5 (empty -> .) ]
  ! TEXT            [ reduce using rule 5 (empty -> .) ]
  ! STRING          [ reduce using rule 5 (empty -> .) ]
  ! NIL             [ reduce using rule 5 (empty -> .) ]
  ! LBrack          [ reduce using rule 5 (empty -> .) ]
  ! FUNC            [ reduce using rule 5 (empty -> .) ]
  ! PRINT           [ reduce using rule 5 (empty -> .) ]
  ! TRUE            [ reduce using rule 5 (empty -> .) ]
  ! FALSE           [ reduce using rule 5 (empty -> .) ]
  ! MATH            [ reduce using rule 22 (atom -> .) ]
  ! Eq              [ reduce using rule 22 (atom -> .) ]
  ! LPAREN          [ reduce using rule 22 (atom -> .) ]
  ! NUM             [ reduce using rule 22 (atom -> .) ]
  ! TEXT            [ reduce using rule 22 (atom -> .) ]
  ! STRING          [ reduce using rule 22 (atom -> .) ]
  ! NIL             [ reduce using rule 22 (atom -> .) ]
  ! LBrack          [ reduce using rule 22 (atom -> .) ]
  ! FUNC            [ reduce using rule 22 (atom -> .) ]
  ! PRINT           [ reduce using rule 22 (atom -> .) ]
  ! TRUE            [ reduce using rule 22 (atom -> .) ]
  ! FALSE           [ reduce using rule 22 (atom -> .) ]
  ! RCURLY          [ reduce using rule 22 (atom -> .) ]

    item                           shift and go to state 17
    bool                           shift and go to state 3
    empty                          shift and go to state 18
    call                           shift and go to state 19
    atom                           shift and go to state 20
    items                          shift and go to state 28

state 39

    (8) item -> empty .
    (4) items -> empty .

  ! reduce/reduce conflict for RCURLY resolved using rule 4 (items -> empty .)
    MATH            reduce using rule 8 (item -> empty .)
    Eq              reduce using rule 8 (item -> empty .)
    LPAREN          reduce using rule 8 (item -> empty .)
    NUM             reduce using rule 8 (item -> empty .)
    TEXT            reduce using rule 8 (item -> empty .)
    STRING          reduce using rule 8 (item -> empty .)
    NIL             reduce using rule 8 (item -> empty .)
    LBrack          reduce using rule 8 (item -> empty .)
    FUNC            reduce using rule 8 (item -> empty .)
    PRINT           reduce using rule 8 (item -> empty .)
    TRUE            reduce using rule 8 (item -> empty .)
    FALSE           reduce using rule 8 (item -> empty .)
    RCURLY          reduce using rule 4 (items -> empty .)

  ! RCURLY          [ reduce using rule 8 (item -> empty .) ]


state 40

    (14) call -> FUNC item LPAREN items RPAREN LCURLY items . RCURLY

    RCURLY          shift and go to state 42


state 41

    (12) call -> FUNC item LPAREN items RPAREN LCURLY item MATH . item RCURLY
    (13) call -> FUNC item LPAREN items RPAREN LCURLY item MATH . item MATH item RCURLY
    (9) call -> item MATH . item
    (19) atom -> MATH .
    (6) item -> . atom
    (7) item -> . call
    (8) item -> . empty
    (17) atom -> . bool
    (18) atom -> . NUM
    (19) atom -> . MATH
    (20) atom -> . TEXT
    (21) atom -> . STRING
    (22) atom -> .
    (25) atom -> . NIL
    (9) call -> . item MATH item
    (10) call -> . item Eq item
    (11) call -> . LBrack items RBrack
    (12) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY
    (13) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY
    (14) call -> . FUNC item LPAREN items RPAREN LCURLY items RCURLY
    (15) call -> . item LPAREN items RPAREN
    (16) call -> . PRINT items
    (5) empty -> .
    (23) bool -> . TRUE
    (24) bool -> . FALSE

  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for MATH resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! reduce/reduce conflict for RCURLY resolved using rule 19 (atom -> MATH .)
  ! shift/reduce conflict for MATH resolved as shift
  ! reduce/reduce conflict for Eq resolved using rule 19 (atom -> MATH .)
  ! reduce/reduce conflict for LPAREN resolved using rule 19 (atom -> MATH .)
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! reduce/reduce conflict for NIL resolved using rule 19 (atom -> MATH .)
  ! reduce/reduce conflict for LBrack resolved using rule 19 (atom -> MATH .)
  ! reduce/reduce conflict for FUNC resolved using rule 19 (atom -> MATH .)
  ! reduce/reduce conflict for PRINT resolved using rule 19 (atom -> MATH .)
  ! reduce/reduce conflict for TRUE resolved using rule 19 (atom -> MATH .)
  ! reduce/reduce conflict for FALSE resolved using rule 19 (atom -> MATH .)
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for LBrack resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! reduce/reduce conflict for RCURLY resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for MATH resolved as shift
  ! reduce/reduce conflict for Eq resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for LPAREN resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for LBrack resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! reduce/reduce conflict for TRUE resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    NUM             shift and go to state 5
    MATH            shift and go to state 9
    TEXT            shift and go to state 7
    STRING          shift and go to state 13
    NIL             shift and go to state 12
    LBrack          shift and go to state 8
    FUNC            shift and go to state 4
    PRINT           shift and go to state 1
    RCURLY          reduce using rule 5 (empty -> .)
    Eq              reduce using rule 5 (empty -> .)
    LPAREN          reduce using rule 5 (empty -> .)
    TRUE            shift and go to state 6
    FALSE           shift and go to state 14

  ! MATH            [ reduce using rule 19 (atom -> MATH .) ]
  ! Eq              [ reduce using rule 19 (atom -> MATH .) ]
  ! LPAREN          [ reduce using rule 19 (atom -> MATH .) ]
  ! NUM             [ reduce using rule 19 (atom -> MATH .) ]
  ! TEXT            [ reduce using rule 19 (atom -> MATH .) ]
  ! STRING          [ reduce using rule 19 (atom -> MATH .) ]
  ! NIL             [ reduce using rule 19 (atom -> MATH .) ]
  ! LBrack          [ reduce using rule 19 (atom -> MATH .) ]
  ! FUNC            [ reduce using rule 19 (atom -> MATH .) ]
  ! PRINT           [ reduce using rule 19 (atom -> MATH .) ]
  ! TRUE            [ reduce using rule 19 (atom -> MATH .) ]
  ! FALSE           [ reduce using rule 19 (atom -> MATH .) ]
  ! RCURLY          [ reduce using rule 19 (atom -> MATH .) ]
  ! RCURLY          [ reduce using rule 22 (atom -> .) ]
  ! MATH            [ reduce using rule 22 (atom -> .) ]
  ! Eq              [ reduce using rule 22 (atom -> .) ]
  ! LPAREN          [ reduce using rule 22 (atom -> .) ]
  ! NUM             [ reduce using rule 22 (atom -> .) ]
  ! TEXT            [ reduce using rule 22 (atom -> .) ]
  ! STRING          [ reduce using rule 22 (atom -> .) ]
  ! NIL             [ reduce using rule 22 (atom -> .) ]
  ! LBrack          [ reduce using rule 22 (atom -> .) ]
  ! FUNC            [ reduce using rule 22 (atom -> .) ]
  ! PRINT           [ reduce using rule 22 (atom -> .) ]
  ! TRUE            [ reduce using rule 22 (atom -> .) ]
  ! FALSE           [ reduce using rule 22 (atom -> .) ]
  ! MATH            [ reduce using rule 5 (empty -> .) ]
  ! NUM             [ reduce using rule 5 (empty -> .) ]
  ! TEXT            [ reduce using rule 5 (empty -> .) ]
  ! STRING          [ reduce using rule 5 (empty -> .) ]
  ! NIL             [ reduce using rule 5 (empty -> .) ]
  ! LBrack          [ reduce using rule 5 (empty -> .) ]
  ! FUNC            [ reduce using rule 5 (empty -> .) ]
  ! PRINT           [ reduce using rule 5 (empty -> .) ]
  ! TRUE            [ reduce using rule 5 (empty -> .) ]
  ! FALSE           [ reduce using rule 5 (empty -> .) ]

    item                           shift and go to state 43
    bool                           shift and go to state 3
    empty                          shift and go to state 10
    call                           shift and go to state 19
    atom                           shift and go to state 20

state 42

    (14) call -> FUNC item LPAREN items RPAREN LCURLY items RCURLY .

    $end            reduce using rule 14 (call -> FUNC item LPAREN items RPAREN LCURLY items RCURLY .)
    MATH            reduce using rule 14 (call -> FUNC item LPAREN items RPAREN LCURLY items RCURLY .)
    Eq              reduce using rule 14 (call -> FUNC item LPAREN items RPAREN LCURLY items RCURLY .)
    LPAREN          reduce using rule 14 (call -> FUNC item LPAREN items RPAREN LCURLY items RCURLY .)
    NUM             reduce using rule 14 (call -> FUNC item LPAREN items RPAREN LCURLY items RCURLY .)
    TEXT            reduce using rule 14 (call -> FUNC item LPAREN items RPAREN LCURLY items RCURLY .)
    STRING          reduce using rule 14 (call -> FUNC item LPAREN items RPAREN LCURLY items RCURLY .)
    NIL             reduce using rule 14 (call -> FUNC item LPAREN items RPAREN LCURLY items RCURLY .)
    LBrack          reduce using rule 14 (call -> FUNC item LPAREN items RPAREN LCURLY items RCURLY .)
    FUNC            reduce using rule 14 (call -> FUNC item LPAREN items RPAREN LCURLY items RCURLY .)
    PRINT           reduce using rule 14 (call -> FUNC item LPAREN items RPAREN LCURLY items RCURLY .)
    TRUE            reduce using rule 14 (call -> FUNC item LPAREN items RPAREN LCURLY items RCURLY .)
    FALSE           reduce using rule 14 (call -> FUNC item LPAREN items RPAREN LCURLY items RCURLY .)
    RBrack          reduce using rule 14 (call -> FUNC item LPAREN items RPAREN LCURLY items RCURLY .)
    RPAREN          reduce using rule 14 (call -> FUNC item LPAREN items RPAREN LCURLY items RCURLY .)
    RCURLY          reduce using rule 14 (call -> FUNC item LPAREN items RPAREN LCURLY items RCURLY .)


state 43

    (12) call -> FUNC item LPAREN items RPAREN LCURLY item MATH item . RCURLY
    (13) call -> FUNC item LPAREN items RPAREN LCURLY item MATH item . MATH item RCURLY
    (9) call -> item MATH item .
    (9) call -> item . MATH item
    (10) call -> item . Eq item
    (15) call -> item . LPAREN items RPAREN

  ! shift/reduce conflict for MATH resolved as shift
  ! shift/reduce conflict for RCURLY resolved as shift
  ! shift/reduce conflict for Eq resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    RCURLY          shift and go to state 45
    MATH            shift and go to state 44
    NUM             reduce using rule 9 (call -> item MATH item .)
    TEXT            reduce using rule 9 (call -> item MATH item .)
    STRING          reduce using rule 9 (call -> item MATH item .)
    NIL             reduce using rule 9 (call -> item MATH item .)
    LBrack          reduce using rule 9 (call -> item MATH item .)
    FUNC            reduce using rule 9 (call -> item MATH item .)
    PRINT           reduce using rule 9 (call -> item MATH item .)
    TRUE            reduce using rule 9 (call -> item MATH item .)
    FALSE           reduce using rule 9 (call -> item MATH item .)
    Eq              shift and go to state 24
    LPAREN          shift and go to state 22

  ! MATH            [ reduce using rule 9 (call -> item MATH item .) ]
  ! Eq              [ reduce using rule 9 (call -> item MATH item .) ]
  ! LPAREN          [ reduce using rule 9 (call -> item MATH item .) ]
  ! RCURLY          [ reduce using rule 9 (call -> item MATH item .) ]


state 44

    (13) call -> FUNC item LPAREN items RPAREN LCURLY item MATH item MATH . item RCURLY
    (9) call -> item MATH . item
    (6) item -> . atom
    (7) item -> . call
    (8) item -> . empty
    (17) atom -> . bool
    (18) atom -> . NUM
    (19) atom -> . MATH
    (20) atom -> . TEXT
    (21) atom -> . STRING
    (22) atom -> .
    (25) atom -> . NIL
    (9) call -> . item MATH item
    (10) call -> . item Eq item
    (11) call -> . LBrack items RBrack
    (12) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY
    (13) call -> . FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY
    (14) call -> . FUNC item LPAREN items RPAREN LCURLY items RCURLY
    (15) call -> . item LPAREN items RPAREN
    (16) call -> . PRINT items
    (5) empty -> .
    (23) bool -> . TRUE
    (24) bool -> . FALSE

  ! shift/reduce conflict for MATH resolved as shift
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for LBrack resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! reduce/reduce conflict for RCURLY resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for MATH resolved as shift
  ! reduce/reduce conflict for Eq resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for LPAREN resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for NUM resolved as shift
  ! shift/reduce conflict for TEXT resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NIL resolved as shift
  ! shift/reduce conflict for LBrack resolved as shift
  ! shift/reduce conflict for FUNC resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! reduce/reduce conflict for TRUE resolved using rule 5 (empty -> .)
  ! reduce/reduce conflict for FALSE resolved using rule 5 (empty -> .)
  ! shift/reduce conflict for TRUE resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
    NUM             shift and go to state 5
    MATH            shift and go to state 9
    TEXT            shift and go to state 7
    STRING          shift and go to state 13
    NIL             shift and go to state 12
    LBrack          shift and go to state 8
    FUNC            shift and go to state 4
    PRINT           shift and go to state 1
    RCURLY          reduce using rule 5 (empty -> .)
    Eq              reduce using rule 5 (empty -> .)
    LPAREN          reduce using rule 5 (empty -> .)
    TRUE            shift and go to state 6
    FALSE           shift and go to state 14

  ! RCURLY          [ reduce using rule 22 (atom -> .) ]
  ! MATH            [ reduce using rule 22 (atom -> .) ]
  ! Eq              [ reduce using rule 22 (atom -> .) ]
  ! LPAREN          [ reduce using rule 22 (atom -> .) ]
  ! NUM             [ reduce using rule 22 (atom -> .) ]
  ! TEXT            [ reduce using rule 22 (atom -> .) ]
  ! STRING          [ reduce using rule 22 (atom -> .) ]
  ! NIL             [ reduce using rule 22 (atom -> .) ]
  ! LBrack          [ reduce using rule 22 (atom -> .) ]
  ! FUNC            [ reduce using rule 22 (atom -> .) ]
  ! PRINT           [ reduce using rule 22 (atom -> .) ]
  ! TRUE            [ reduce using rule 22 (atom -> .) ]
  ! FALSE           [ reduce using rule 22 (atom -> .) ]
  ! MATH            [ reduce using rule 5 (empty -> .) ]
  ! NUM             [ reduce using rule 5 (empty -> .) ]
  ! TEXT            [ reduce using rule 5 (empty -> .) ]
  ! STRING          [ reduce using rule 5 (empty -> .) ]
  ! NIL             [ reduce using rule 5 (empty -> .) ]
  ! LBrack          [ reduce using rule 5 (empty -> .) ]
  ! FUNC            [ reduce using rule 5 (empty -> .) ]
  ! PRINT           [ reduce using rule 5 (empty -> .) ]
  ! TRUE            [ reduce using rule 5 (empty -> .) ]
  ! FALSE           [ reduce using rule 5 (empty -> .) ]

    item                           shift and go to state 46
    bool                           shift and go to state 3
    empty                          shift and go to state 10
    call                           shift and go to state 19
    atom                           shift and go to state 20

state 45

    (12) call -> FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY .

    $end            reduce using rule 12 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY .)
    MATH            reduce using rule 12 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY .)
    Eq              reduce using rule 12 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY .)
    LPAREN          reduce using rule 12 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY .)
    NUM             reduce using rule 12 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY .)
    TEXT            reduce using rule 12 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY .)
    STRING          reduce using rule 12 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY .)
    NIL             reduce using rule 12 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY .)
    LBrack          reduce using rule 12 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY .)
    FUNC            reduce using rule 12 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY .)
    PRINT           reduce using rule 12 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY .)
    TRUE            reduce using rule 12 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY .)
    FALSE           reduce using rule 12 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY .)
    RBrack          reduce using rule 12 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY .)
    RPAREN          reduce using rule 12 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY .)
    RCURLY          reduce using rule 12 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item RCURLY .)


state 46

    (13) call -> FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item . RCURLY
    (9) call -> item MATH item .
    (9) call -> item . MATH item
    (10) call -> item . Eq item
    (15) call -> item . LPAREN items RPAREN

  ! shift/reduce conflict for RCURLY resolved as shift
  ! shift/reduce conflict for MATH resolved as shift
  ! shift/reduce conflict for Eq resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
    RCURLY          shift and go to state 47
    NUM             reduce using rule 9 (call -> item MATH item .)
    TEXT            reduce using rule 9 (call -> item MATH item .)
    STRING          reduce using rule 9 (call -> item MATH item .)
    NIL             reduce using rule 9 (call -> item MATH item .)
    LBrack          reduce using rule 9 (call -> item MATH item .)
    FUNC            reduce using rule 9 (call -> item MATH item .)
    PRINT           reduce using rule 9 (call -> item MATH item .)
    TRUE            reduce using rule 9 (call -> item MATH item .)
    FALSE           reduce using rule 9 (call -> item MATH item .)
    MATH            shift and go to state 23
    Eq              shift and go to state 24
    LPAREN          shift and go to state 22

  ! RCURLY          [ reduce using rule 9 (call -> item MATH item .) ]
  ! MATH            [ reduce using rule 9 (call -> item MATH item .) ]
  ! Eq              [ reduce using rule 9 (call -> item MATH item .) ]
  ! LPAREN          [ reduce using rule 9 (call -> item MATH item .) ]


state 47

    (13) call -> FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY .

    $end            reduce using rule 13 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY .)
    MATH            reduce using rule 13 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY .)
    Eq              reduce using rule 13 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY .)
    LPAREN          reduce using rule 13 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY .)
    NUM             reduce using rule 13 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY .)
    TEXT            reduce using rule 13 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY .)
    STRING          reduce using rule 13 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY .)
    NIL             reduce using rule 13 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY .)
    LBrack          reduce using rule 13 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY .)
    FUNC            reduce using rule 13 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY .)
    PRINT           reduce using rule 13 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY .)
    TRUE            reduce using rule 13 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY .)
    FALSE           reduce using rule 13 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY .)
    RBrack          reduce using rule 13 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY .)
    RPAREN          reduce using rule 13 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY .)
    RCURLY          reduce using rule 13 (call -> FUNC item LPAREN items RPAREN LCURLY item MATH item MATH item RCURLY .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for MATH in state 0 resolved as shift
WARNING: shift/reduce conflict for MATH in state 0 resolved as shift
WARNING: shift/reduce conflict for NUM in state 1 resolved as shift
WARNING: shift/reduce conflict for MATH in state 1 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 1 resolved as shift
WARNING: shift/reduce conflict for STRING in state 1 resolved as shift
WARNING: shift/reduce conflict for MATH in state 1 resolved as shift
WARNING: shift/reduce conflict for NUM in state 1 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 1 resolved as shift
WARNING: shift/reduce conflict for STRING in state 1 resolved as shift
WARNING: shift/reduce conflict for NIL in state 1 resolved as shift
WARNING: shift/reduce conflict for LBrack in state 1 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 1 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 1 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 1 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 1 resolved as shift
WARNING: shift/reduce conflict for MATH in state 4 resolved as shift
WARNING: shift/reduce conflict for MATH in state 4 resolved as shift
WARNING: shift/reduce conflict for NUM in state 8 resolved as shift
WARNING: shift/reduce conflict for MATH in state 8 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 8 resolved as shift
WARNING: shift/reduce conflict for STRING in state 8 resolved as shift
WARNING: shift/reduce conflict for MATH in state 8 resolved as shift
WARNING: shift/reduce conflict for NUM in state 8 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 8 resolved as shift
WARNING: shift/reduce conflict for STRING in state 8 resolved as shift
WARNING: shift/reduce conflict for NIL in state 8 resolved as shift
WARNING: shift/reduce conflict for LBrack in state 8 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 8 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 8 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 8 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 8 resolved as shift
WARNING: shift/reduce conflict for MATH in state 17 resolved as shift
WARNING: shift/reduce conflict for Eq in state 17 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 17 resolved as shift
WARNING: shift/reduce conflict for NUM in state 17 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 17 resolved as shift
WARNING: shift/reduce conflict for STRING in state 17 resolved as shift
WARNING: shift/reduce conflict for MATH in state 17 resolved as shift
WARNING: shift/reduce conflict for Eq in state 17 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 17 resolved as shift
WARNING: shift/reduce conflict for NUM in state 17 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 17 resolved as shift
WARNING: shift/reduce conflict for STRING in state 17 resolved as shift
WARNING: shift/reduce conflict for NIL in state 17 resolved as shift
WARNING: shift/reduce conflict for LBrack in state 17 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 17 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 17 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 17 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 17 resolved as shift
WARNING: shift/reduce conflict for NUM in state 22 resolved as shift
WARNING: shift/reduce conflict for MATH in state 22 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 22 resolved as shift
WARNING: shift/reduce conflict for STRING in state 22 resolved as shift
WARNING: shift/reduce conflict for MATH in state 22 resolved as shift
WARNING: shift/reduce conflict for NUM in state 22 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 22 resolved as shift
WARNING: shift/reduce conflict for STRING in state 22 resolved as shift
WARNING: shift/reduce conflict for NIL in state 22 resolved as shift
WARNING: shift/reduce conflict for LBrack in state 22 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 22 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 22 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 22 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 22 resolved as shift
WARNING: shift/reduce conflict for MATH in state 23 resolved as shift
WARNING: shift/reduce conflict for NUM in state 23 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 23 resolved as shift
WARNING: shift/reduce conflict for STRING in state 23 resolved as shift
WARNING: shift/reduce conflict for NIL in state 23 resolved as shift
WARNING: shift/reduce conflict for LBrack in state 23 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 23 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 23 resolved as shift
WARNING: shift/reduce conflict for MATH in state 23 resolved as shift
WARNING: shift/reduce conflict for NUM in state 23 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 23 resolved as shift
WARNING: shift/reduce conflict for STRING in state 23 resolved as shift
WARNING: shift/reduce conflict for NIL in state 23 resolved as shift
WARNING: shift/reduce conflict for LBrack in state 23 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 23 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 23 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 23 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 23 resolved as shift
WARNING: shift/reduce conflict for MATH in state 24 resolved as shift
WARNING: shift/reduce conflict for NUM in state 24 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 24 resolved as shift
WARNING: shift/reduce conflict for STRING in state 24 resolved as shift
WARNING: shift/reduce conflict for NIL in state 24 resolved as shift
WARNING: shift/reduce conflict for LBrack in state 24 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 24 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 24 resolved as shift
WARNING: shift/reduce conflict for MATH in state 24 resolved as shift
WARNING: shift/reduce conflict for NUM in state 24 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 24 resolved as shift
WARNING: shift/reduce conflict for STRING in state 24 resolved as shift
WARNING: shift/reduce conflict for NIL in state 24 resolved as shift
WARNING: shift/reduce conflict for LBrack in state 24 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 24 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 24 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 24 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 24 resolved as shift
WARNING: shift/reduce conflict for NUM in state 27 resolved as shift
WARNING: shift/reduce conflict for MATH in state 27 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 27 resolved as shift
WARNING: shift/reduce conflict for STRING in state 27 resolved as shift
WARNING: shift/reduce conflict for MATH in state 27 resolved as shift
WARNING: shift/reduce conflict for NUM in state 27 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 27 resolved as shift
WARNING: shift/reduce conflict for STRING in state 27 resolved as shift
WARNING: shift/reduce conflict for NIL in state 27 resolved as shift
WARNING: shift/reduce conflict for LBrack in state 27 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 27 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 27 resolved as shift
WARNING: shift/reduce conflict for MATH in state 27 resolved as shift
WARNING: shift/reduce conflict for NUM in state 27 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 27 resolved as shift
WARNING: shift/reduce conflict for STRING in state 27 resolved as shift
WARNING: shift/reduce conflict for NIL in state 27 resolved as shift
WARNING: shift/reduce conflict for LBrack in state 27 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 27 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 27 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 27 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 27 resolved as shift
WARNING: shift/reduce conflict for MATH in state 30 resolved as shift
WARNING: shift/reduce conflict for Eq in state 30 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 30 resolved as shift
WARNING: shift/reduce conflict for MATH in state 31 resolved as shift
WARNING: shift/reduce conflict for Eq in state 31 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 31 resolved as shift
WARNING: shift/reduce conflict for NUM in state 32 resolved as shift
WARNING: shift/reduce conflict for MATH in state 32 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 32 resolved as shift
WARNING: shift/reduce conflict for STRING in state 32 resolved as shift
WARNING: shift/reduce conflict for MATH in state 32 resolved as shift
WARNING: shift/reduce conflict for NUM in state 32 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 32 resolved as shift
WARNING: shift/reduce conflict for STRING in state 32 resolved as shift
WARNING: shift/reduce conflict for NIL in state 32 resolved as shift
WARNING: shift/reduce conflict for LBrack in state 32 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 32 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 32 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 32 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 32 resolved as shift
WARNING: shift/reduce conflict for MATH in state 37 resolved as shift
WARNING: shift/reduce conflict for NUM in state 37 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 37 resolved as shift
WARNING: shift/reduce conflict for STRING in state 37 resolved as shift
WARNING: shift/reduce conflict for NIL in state 37 resolved as shift
WARNING: shift/reduce conflict for LBrack in state 37 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 37 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 37 resolved as shift
WARNING: shift/reduce conflict for MATH in state 37 resolved as shift
WARNING: shift/reduce conflict for NUM in state 37 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 37 resolved as shift
WARNING: shift/reduce conflict for STRING in state 37 resolved as shift
WARNING: shift/reduce conflict for NIL in state 37 resolved as shift
WARNING: shift/reduce conflict for LBrack in state 37 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 37 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 37 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 37 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 37 resolved as shift
WARNING: shift/reduce conflict for MATH in state 38 resolved as shift
WARNING: shift/reduce conflict for Eq in state 38 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 38 resolved as shift
WARNING: shift/reduce conflict for NUM in state 38 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 38 resolved as shift
WARNING: shift/reduce conflict for STRING in state 38 resolved as shift
WARNING: shift/reduce conflict for MATH in state 38 resolved as shift
WARNING: shift/reduce conflict for Eq in state 38 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 38 resolved as shift
WARNING: shift/reduce conflict for NUM in state 38 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 38 resolved as shift
WARNING: shift/reduce conflict for STRING in state 38 resolved as shift
WARNING: shift/reduce conflict for NIL in state 38 resolved as shift
WARNING: shift/reduce conflict for LBrack in state 38 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 38 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 38 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 38 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 38 resolved as shift
WARNING: shift/reduce conflict for NUM in state 41 resolved as shift
WARNING: shift/reduce conflict for MATH in state 41 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 41 resolved as shift
WARNING: shift/reduce conflict for STRING in state 41 resolved as shift
WARNING: shift/reduce conflict for MATH in state 41 resolved as shift
WARNING: shift/reduce conflict for NUM in state 41 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 41 resolved as shift
WARNING: shift/reduce conflict for STRING in state 41 resolved as shift
WARNING: shift/reduce conflict for NIL in state 41 resolved as shift
WARNING: shift/reduce conflict for LBrack in state 41 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 41 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 41 resolved as shift
WARNING: shift/reduce conflict for MATH in state 41 resolved as shift
WARNING: shift/reduce conflict for NUM in state 41 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 41 resolved as shift
WARNING: shift/reduce conflict for STRING in state 41 resolved as shift
WARNING: shift/reduce conflict for NIL in state 41 resolved as shift
WARNING: shift/reduce conflict for LBrack in state 41 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 41 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 41 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 41 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 41 resolved as shift
WARNING: shift/reduce conflict for MATH in state 43 resolved as shift
WARNING: shift/reduce conflict for RCURLY in state 43 resolved as shift
WARNING: shift/reduce conflict for Eq in state 43 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 43 resolved as shift
WARNING: shift/reduce conflict for MATH in state 44 resolved as shift
WARNING: shift/reduce conflict for NUM in state 44 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 44 resolved as shift
WARNING: shift/reduce conflict for STRING in state 44 resolved as shift
WARNING: shift/reduce conflict for NIL in state 44 resolved as shift
WARNING: shift/reduce conflict for LBrack in state 44 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 44 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 44 resolved as shift
WARNING: shift/reduce conflict for MATH in state 44 resolved as shift
WARNING: shift/reduce conflict for NUM in state 44 resolved as shift
WARNING: shift/reduce conflict for TEXT in state 44 resolved as shift
WARNING: shift/reduce conflict for STRING in state 44 resolved as shift
WARNING: shift/reduce conflict for NIL in state 44 resolved as shift
WARNING: shift/reduce conflict for LBrack in state 44 resolved as shift
WARNING: shift/reduce conflict for FUNC in state 44 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 44 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 44 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 44 resolved as shift
WARNING: shift/reduce conflict for RCURLY in state 46 resolved as shift
WARNING: shift/reduce conflict for MATH in state 46 resolved as shift
WARNING: shift/reduce conflict for Eq in state 46 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 46 resolved as shift
WARNING: reduce/reduce conflict in state 0 resolved using rule (empty -> <empty>)
WARNING: rejected rule (atom -> <empty>) in state 0
WARNING: reduce/reduce conflict in state 1 resolved using rule (empty -> <empty>)
WARNING: rejected rule (atom -> <empty>) in state 1
WARNING: reduce/reduce conflict in state 4 resolved using rule (empty -> <empty>)
WARNING: rejected rule (atom -> <empty>) in state 4
WARNING: reduce/reduce conflict in state 8 resolved using rule (empty -> <empty>)
WARNING: rejected rule (atom -> <empty>) in state 8
WARNING: reduce/reduce conflict in state 17 resolved using rule (empty -> <empty>)
WARNING: rejected rule (atom -> <empty>) in state 17
WARNING: reduce/reduce conflict in state 18 resolved using rule (items -> empty)
WARNING: rejected rule (item -> empty) in state 18
WARNING: reduce/reduce conflict in state 22 resolved using rule (empty -> <empty>)
WARNING: rejected rule (atom -> <empty>) in state 22
WARNING: reduce/reduce conflict in state 23 resolved using rule (empty -> <empty>)
WARNING: rejected rule (atom -> <empty>) in state 23
WARNING: reduce/reduce conflict in state 24 resolved using rule (empty -> <empty>)
WARNING: rejected rule (atom -> <empty>) in state 24
WARNING: reduce/reduce conflict in state 27 resolved using rule (atom -> MATH)
WARNING: rejected rule (atom -> <empty>) in state 27
WARNING: reduce/reduce conflict in state 27 resolved using rule (empty -> <empty>)
WARNING: rejected rule (atom -> MATH) in state 27
WARNING: reduce/reduce conflict in state 32 resolved using rule (empty -> <empty>)
WARNING: rejected rule (atom -> <empty>) in state 32
WARNING: reduce/reduce conflict in state 37 resolved using rule (empty -> <empty>)
WARNING: rejected rule (atom -> <empty>) in state 37
WARNING: reduce/reduce conflict in state 38 resolved using rule (empty -> <empty>)
WARNING: rejected rule (atom -> <empty>) in state 38
WARNING: reduce/reduce conflict in state 39 resolved using rule (items -> empty)
WARNING: rejected rule (item -> empty) in state 39
WARNING: reduce/reduce conflict in state 41 resolved using rule (atom -> MATH)
WARNING: rejected rule (atom -> <empty>) in state 41
WARNING: reduce/reduce conflict in state 41 resolved using rule (empty -> <empty>)
WARNING: rejected rule (atom -> MATH) in state 41
WARNING: reduce/reduce conflict in state 44 resolved using rule (empty -> <empty>)
WARNING: rejected rule (atom -> <empty>) in state 44
